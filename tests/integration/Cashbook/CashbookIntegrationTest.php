<?php

declare(strict_types=1);

namespace Model\Cashbook;

use Cake\Chronos\ChronosDate;
use Helpers;
use IntegrationTest;
use Model\Cashbook\Cashbook\Amount;
use Model\Cashbook\Cashbook\CashbookId;
use Model\Cashbook\Cashbook\CashbookType;
use Model\Cashbook\Cashbook\ChitBody;
use Model\Cashbook\Cashbook\ChitItem;
use Model\Cashbook\Cashbook\ChitNumber;
use Model\Cashbook\Cashbook\PaymentMethod;
use Model\Cashbook\Cashbook\Recipient;
use Model\Cashbook\Events\ChitWasAdded;
use Model\Cashbook\Events\ChitWasRemoved;
use Model\Cashbook\Events\ChitWasUpdated;
use Model\Common\FilePath;
use Model\Common\ScanNotFound;

use function assert;

/**
 * These are in fact unit tests, that can't be tested without database right now, because chit ids are
 * autogenerated. This should be refactored to use composite keys ( @see \Model\Travel\Command ) and moved to unit suite
 */
class CashbookIntegrationTest extends IntegrationTest
{
    /** @return string[] */
    public function getTestedAggregateRoots(): array
    {
        return [Cashbook::class];
    }

    public function testLockingLockedChitDoesNothing(): void
    {
        $cashbook = $this->createCashbookWithLockedChit();

        $cashbook->lockChit(1, 10);

        $this->assertEmpty($cashbook->extractEventsToDispatch());
    }

    public function testUnlockingUnlockedChitDoesNothing(): void
    {
        $cashbook = $this->createCashbookWithChit();

        $cashbook->unlockChit(1);

        $this->assertEmpty($cashbook->extractEventsToDispatch());
    }

    public function testUnlockedChitCanBeUpdated(): void
    {
        $cashbookId    = CashbookId::generate();
        $cashbook      = $this->createCashbookWithLockedChit($cashbookId);
        $categoryId    = 1;
        $category      = Helpers::mockChitItemCategory($categoryId);
        $categories    = Helpers::mockCashbookCategories($categoryId);
        $amount        = new Cashbook\Amount('100');
        $date          = new ChronosDate('2017-11-17');
        $recipient     = new Recipient('František Maša');
        $paymentMethod = PaymentMethod::BANK();

        $cashbook->unlockChit(1);
        $cashbook->updateChit(
            1,
            new ChitBody(null, $date, $recipient),
            $paymentMethod,
            [new ChitItem($amount, $category, 'purpose')],
            $categories,
        );

        $event = $cashbook->extractEventsToDispatch()[0];
        $this->assertInstanceOf(ChitWasUpdated::class, $event);
        $this->assertTrue($event->getCashbookId()->equals($cashbookId));
    }

    public function testUpdateOfLockedChitThrowsException(): void
    {
        $cashbook      = $this->createCashbookWithLockedChit();
        $categoryId    = 666;
        $category      = Helpers::mockChitItemCategory($categoryId);
        $categories    = Helpers::mockCashbookCategories($categoryId);
        $date          = new ChronosDate('2017-11-17');
        $amount        = new Cashbook\Amount('100');
        $paymentMethod = PaymentMethod::CASH();
        $this->expectException(ChitLocked::class);

        $cashbook->updateChit(
            1,
            new ChitBody(null, $date, null),
            $paymentMethod,
            [new ChitItem($amount, $category, 'new-purpose')],
            $categories,
        );
    }

    public function testUpdateOfNonExistentChitThrowsException(): void
    {
        $cashbook      = $this->createCashbookWithChit();
        $categoryId    = 666;
        $category      = Helpers::mockChitItemCategory($categoryId);
        $categories    = Helpers::mockCashbookCategories($categoryId);
        $amount        = new Cashbook\Amount('100');
        $date          = new ChronosDate('2017-11-17');
        $paymentMethod = PaymentMethod::CASH();

        $this->expectException(ChitNotFound::class);

        $cashbook->updateChit(
            2,
            new ChitBody(null, $date, null),
            $paymentMethod,
            [new ChitItem($amount, $category, 'new-purpose')],
            $categories,
        );
    }

    public function testRemoveChit(): void
    {
        $cashbookId = CashbookId::generate();
        $cashbook   = $this->createCashbookWithChit(CashbookType::EVENT, $cashbookId);

        $cashbook->removeChit(1);

        $this->assertSame([], $cashbook->getCategoryTotals()); // no chits => no categories

        $event = $cashbook->extractEventsToDispatch()[0];
        $this->assertInstanceOf(ChitWasRemoved::class, $event);
        $this->assertTrue($event->getCashbookId()->equals($cashbookId));
        $this->assertSame('purpose', $event->getChitPurpose());

        // Test that everything cascades correctly
        $this->entityManager->persist($cashbook);
        $this->entityManager->flush();
    }

    public function testRemovalOfLockedChitThrowsException(): void
    {
        $cashbook = $this->createCashbookWithLockedChit();

        $this->expectException(ChitLocked::class);

        $cashbook->removeChit(1);
    }

    public function testRemovalOfNonExistentChitThrowsException(): void
    {
        $cashbook = $this->createCashbookWithChit();

        $this->expectException(ChitNotFound::class);

        $cashbook->removeChit(2);
    }

    private function createCashbookWithLockedChit(CashbookId|null $cashbookId = null): Cashbook
    {
        $cashbook = $this->createCashbookWithChit(CashbookType::EVENT, $cashbookId);
        $cashbook->lockChit(1, 10);
        $cashbook->extractEventsToDispatch();

        return $cashbook;
    }

    /** @dataProvider getValidTransfers */
    public function testAddInverseTransferAddsChitToCalledCashbook(
        string $originalCashbookType,
        string $cashbookType,
        string $originalOperation,
        int $originalCategoryId,
        int $newCategoryId,
    ): void {
        $body             = new ChitBody(new ChitNumber('123'), new ChronosDate(), new Recipient('Maša'));
        $originalCashbook = new Cashbook(CashbookId::generate(), CashbookType::get($originalCashbookType));
        $category         = Helpers::mockChitItemCategory($originalCategoryId, Operation::get($originalOperation));
        $categories       = Helpers::mockCashbookCategories($originalCategoryId);

        $originalCashbook->addChit(
            $body,
            PaymentMethod::CASH(),
            [new ChitItem(new Amount('101'), $category, 'transfer')],
            $categories,
        );

        // to generate ID for chit
        $this->entityManager->persist($originalCashbook);
        $this->entityManager->flush();

        $cashbookId = CashbookId::generate();
        $cashbook   = new Cashbook($cashbookId, CashbookType::get($cashbookType));
        $cashbook->addInverseChit($originalCashbook, 1);
        $newChit = $cashbook->getChits()[0];

        $this->entityManager->persist($cashbook);
        $this->entityManager->flush();

        $this->entityManager->refresh($originalCashbook);
        $this->entityManager->refresh($cashbook);

        // inverse chit must have inverse category type
        $this->assertSame(Operation::get($originalOperation)->getInverseOperation(), $newChit->getOperation());
        $this->assertTrue($body->withoutChitNumber()->equals($newChit->getBody()));
        $this->assertSame([$newCategoryId => 101.0], $cashbook->getCategoryTotals());
        $this->assertSame([$originalCategoryId => 101.0], $originalCashbook->getCategoryTotals()); // other cashbook is not changed by this action

        $events = $cashbook->extractEventsToDispatch();

        $this->assertCount(1, $events);

        $event = $events[0];
        assert($event instanceof ChitWasAdded);
        $this->assertTrue($event->getCashbookId()->equals($cashbookId));
    }

    /** @return list<list<mixed>>> */
    public function getValidTransfers(): array
    {
        return [ // expense -> income
            [
                CashbookType::TROOP,
                CashbookType::EVENT,
                Operation::EXPENSE,
                16, // "Převod do akce"
                13, // "Převod z oddílové pokladny"
            ],
            [ // income -> expense
                CashbookType::OFFICIAL_UNIT,
                CashbookType::TROOP,
                Operation::INCOME,
                13, // "Převod z oddílové pokladny"
                7, // "Převod do stř. pokladny"
            ],
        ];
    }

    /** @dataProvider getInvalidInverseChitCategories */
    public function testAddInvalidInverseChitThrowsException(int $invalidCategoryId): void
    {
        $originalCashbook = new Cashbook(CashbookId::generate(), CashbookType::get(CashbookType::OFFICIAL_UNIT));
        $category         = Helpers::mockChitItemCategory($invalidCategoryId, Operation::EXPENSE());
        $categories       = Helpers::mockCashbookCategories($invalidCategoryId);
        $originalCashbook->addChit(
            new ChitBody(new ChitNumber('123'), new ChronosDate(), new Recipient('FM')),
            PaymentMethod::CASH(),
            [new ChitItem(new Amount('100'), $category, 'transfer')],
            $categories,
        );

        // to generate ID for chit
        $this->entityManager->persist($originalCashbook);
        $this->entityManager->flush();

        $cashbook = new Cashbook(CashbookId::generate(), CashbookType::get(CashbookType::EVENT));

        $this->expectException(InvalidCashbookTransfer::class);

        $cashbook->addInverseChit($originalCashbook, 1);
    }

    /** @return list<list<int>> */
    public function getInvalidInverseChitCategories(): array
    {
        return [
            [13], // "Převod z odd. pokladny"
            [14], // "Převod do odd. pokladny"
        ];
    }

    private function createCashbookWithChit(string $type = CashbookType::EVENT, CashbookId|null $cashbookId = null): Cashbook
    {
        $cashbook   = new Cashbook($cashbookId ?? CashbookId::generate(), CashbookType::get($type));
        $categoryId = 666;

        $cashbook->addChit(
            new ChitBody(null, new ChronosDate(), null),
            PaymentMethod::CASH(),
            [new ChitItem(new Amount('100'), Helpers::mockChitItemCategory($categoryId), 'purpose')],
            Helpers::mockCashbookCategories($categoryId),
        );
        $cashbook->extractEventsToDispatch();

        // This assigns ID 1 to chit
        $this->entityManager->persist($cashbook);
        $this->entityManager->flush();

        return $cashbook;
    }

    public function testLock(): void
    {
        $cashbook   = new Cashbook(CashbookId::generate(), CashbookType::get(CashbookType::EVENT));
        $chitBody   = new ChitBody(null, new ChronosDate(), null);
        $categoryId = 666;
        $category   = Helpers::mockChitItemCategory($categoryId);

        for ($i = 0; $i < 5; $i++) {
            $cashbook->addChit(
                $chitBody,
                PaymentMethod::CASH(),
                [new ChitItem(new Amount('100'), $category, 'purpose')],
                Helpers::mockCashbookCategories($categoryId),
            );
        }

        $this->entityManager->persist($cashbook);
        $this->entityManager->flush();

        $cashbook->lockChit(3, 1);

        $cashbook->lock(1);

        $chits = $cashbook->getChits();

        $this->assertCount(5, $chits);
        foreach ($chits as $chit) {
            $this->assertTrue($chit->isLocked());
        }
    }

    public function testCopyingChitRaisesEvent(): void
    {
        $sourceCashbook = $this->createCashbookWithChit();
        $targetCashbook = new Cashbook(CashbookId::generate(), CashbookType::get(CashbookType::EVENT));

        $targetCashbook->copyChitsFrom([1], $sourceCashbook);

        $events = $targetCashbook->extractEventsToDispatch();

        $this->assertCount(1, $events);
        $this->assertInstanceOf(ChitWasAdded::class, $events[0]);
    }

    /** @dataProvider getNonCampCashbookTypes */
    public function testCopyChitsBetweenTwoNonCampCashbooksWithSameType(string $cashbookType): void
    {
        $sourceCashbook = $this->createCashbookWithChit($cashbookType);
        $targetCashbook = new Cashbook(CashbookId::generate(), CashbookType::get($cashbookType));

        $targetCashbook->copyChitsFrom([1], $sourceCashbook);

        $this->assertSame(
            $sourceCashbook->getCategoryTotals(),
            $targetCashbook->getCategoryTotals(),
        );
    }

    /** @return string[][] */
    public function getNonCampCashbookTypes(): array
    {
        return [
            [CashbookType::EVENT],
            [CashbookType::TROOP],
            [CashbookType::OFFICIAL_UNIT],
        ];
    }

    /** @dataProvider getDifferentCashbookTypes */
    public function testCopyChitsBetweenDifferentCashbooksWithDifferentCategories(string $sourceType, string $targetType): void
    {
        $sourceCashbook = $this->createCashbookWithChit($sourceType);
        $targetCashbook = new Cashbook(CashbookId::generate(), CashbookType::get($targetType));

        $targetCashbook->copyChitsFrom([1], $sourceCashbook);

        $chitAmount = $sourceCashbook->getChits()[0]->getAmount()->toFloat();
        $this->assertSame([Category::UNDEFINED_INCOME_ID => $chitAmount], $targetCashbook->getCategoryTotals());
    }

    public function testAddChitScan(): void
    {
        $cashbook = $this->createCashbookWithChit();
        $chit     = $cashbook->getChits()[0];
        $path     = FilePath::fromString('a/b/s.jpg');
        $cashbook->addChitScan($chit->getId(), $path);
        $scans = $chit->getScans();
        $this->assertCount(1, $scans);
        $this->assertSame($path, $scans[0]->getFilePath());
    }

    public function testRemoveChitScanThrowsExceptionIfScanDoesNotExist(): void
    {
        $cashbook = $this->createCashbookWithChit();
        $chit     = $cashbook->getChits()[0];

        $this->expectException(ScanNotFound::class);
        $cashbook->removeChitScan($chit->getId(), FilePath::fromString('Does/not/exists.jpg'));
    }

    public function testRemoveChitScan(): void
    {
        $cashbook = $this->createCashbookWithChit();
        $chit     = $cashbook->getChits()[0];
        $path     = FilePath::fromString('a/b/s.jpg');
        $cashbook->addChitScan($chit->getId(), $path);
        $cashbook->removeChitScan($chit->getId(), $path);

        $this->assertCount(0, $chit->getScans());
    }

    /** @return string[][] */
    public function getDifferentCashbookTypes(): array
    {
        return [
            [CashbookType::EVENT, CashbookType::TROOP],
            [CashbookType::CAMP, CashbookType::CAMP], // camps may have different categories
        ];
    }

    public function testGenerateChitNumbers(): void
    {
        $cashbook = new Cashbook(CashbookId::generate(), CashbookType::get(CashbookType::EVENT));

        Helpers::addChitToCashbook($cashbook, null, PaymentMethod::CASH(), null, null, ChronosDate::today());
        Helpers::addChitToCashbook($cashbook, null, PaymentMethod::BANK());
        Helpers::addChitToCashbook($cashbook, null, PaymentMethod::CASH(), null, null, ChronosDate::yesterday(), Operation::EXPENSE());
        Helpers::addChitToCashbook($cashbook, null, PaymentMethod::CASH(), null, null, ChronosDate::yesterday(), Operation::INCOME());
        Helpers::addChitToCashbook($cashbook, '1', PaymentMethod::CASH());

        $this->entityManager->persist($cashbook);
        $this->entityManager->flush();

        $cashbook->generateChitNumbers(PaymentMethod::CASH());

        $this->assertSame('4', $cashbook->getChits()[0]->getBody()->getNumber()->toString());
        $this->assertNull($cashbook->getChits()[1]->getBody()->getNumber());
        $this->assertSame('3', $cashbook->getChits()[2]->getBody()->getNumber()->toString());
        $this->assertSame('2', $cashbook->getChits()[3]->getBody()->getNumber()->toString());
    }
}
